Name: Simeon Babatunde

Course no: CpSc 8270

Clemson Email Address: sbabatu@g.clemson.edu

Project no: 3

Project due date: October 19, 2018

Project description:
This project focuses on the computation of McCabe complexity through the implementation
of semantic actions within the parser. The Radon tool serves as the ground truth for
evaluating the accuracy of the program's output. Information regarding the complexity
of major python construct were taken from the Radon documentation. A test.py file was
given to enable seamless run of the created test cases. The final implementation requires
additions and/or modifications to the main.cpp, scan.l and parse.y files.


What I have accomplished to implement McCabe's Cyclomatic Complexity
Metric, including using the radon oracle:
I updated the lex scanner to ensure identifiers(name) token gets passed to the parser. I
defined a union type for the name in the parser, allocate memory for it in the scanner and
freed the allocated memory from the semantic actions of the parser. I also created a class
called "Keeper" that holds necessary data fields. The complexity value was incremented in
the production rules that contain the constructs defined in Radon doc. I saved the object
pointers in a vector and then implemented a functor called "SortByComplexity()" to sort the
vector of object pointers in the main.cpp file based on complexity.
The complexity of classes were computed based on the average of function complexity. I wrote
some test cases to verify the accuracy of the program. I also run the test.py test on the
Python-2.7.2 test cases and was able to pass 49 of those test cases. Finally. the Makefile
was updated to include the newly created class.


The easiest part of this project, including what language
construct was the easiest to implement:
Browsing through the parse tree to identify the right location to increment the complexity. Also,
retrieving the row and column numbers seems easy to compute based on initial discussion in class.
It only took few minutes to update the scanner to handle identifier token. The functor
implementation appears to be easy as well.



Problems that I had in completing this project, including what
Python language construct caused the most difficulty:
I took me a while to figure out and fix the memory leakages in the program. I initially tried to use
a Singleton to keep all the information, but couldn't get it to keep the complexity of subsequent
functions. I created a Keeper class to handle the requirement. I had to update test.py to prevent
it from printing the file path generated by radon. The test cases for the try/except construct failed
initially because I incremented the complexity in the try rather than except.
